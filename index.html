<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Chandy &#39;s Home | Noob</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="theme-color" content="#3F51B5">
  
  
  <meta name="keywords" content="undefined">
  <meta name="description" content="love IT !">
<meta property="og:type" content="website">
<meta property="og:title" content="Chandy 's Home">
<meta property="og:url" content="https://chandy1994.github.io/index.html">
<meta property="og:site_name" content="Chandy 's Home">
<meta property="og:description" content="love IT !">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chandy 's Home">
<meta name="twitter:description" content="love IT !">
  
    <link rel="alternative" href="/atom.xml" title="Chandy &#39;s Home" type="application/atom+xml">
  
  <meta name="summary" content="love IT !">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="loading" class="active"></div>

  <nav id="menu"  >
   <div class="inner flex-row-vertical">
  <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="/" class="avatar"><img src="/img/logo.png"></a>
      <hgroup class="introduce">
        <h5 class="nickname">Chandy</h5>
        <a href="mailto:chandy1994@hotmail.com" title="chandy1994@hotmail.com" class="mail">chandy1994@hotmail.com</a>
      </hgroup>
    </div>
  </div>
  <ul class="nav flex-col">
    
        <li class="waves-block waves-effect active">
          <a href="/"  >
            <i class="icon icon-lg icon-home"></i>
            主页
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/archives"  >
            <i class="icon icon-lg icon-archives"></i>
            Archives
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/tags"  >
            <i class="icon icon-lg icon-tags"></i>
            Tags
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="https://github.com/chandy1994" target="_blank" >
            <i class="icon icon-lg icon-github"></i>
            Github
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="http://weibo.com/u/5501169492?refer_flag=1001030102_&is_all=1" target="_blank" >
            <i class="icon icon-lg icon-weibo"></i>
            Weibo
          </a>
        </li>
    
        <li class="waves-block waves-effect">
          <a href="/"  >
            <i class="icon icon-lg icon-link"></i>
            测试
          </a>
        </li>
    
  </ul>

  <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>Chandy &#39;s Home &copy; 2016</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

</div>

  </nav>
  <main id="main">
    <header class="header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Chandy &#39;s Home</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input " autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">Chandy &#39;s Home</h1>
    <h5 class="subtitle">
         
        Noob
        
    </h5>
  </div>
</header>

    <div class="container body-wrap">
      <ul class="post-list">
  
    <li class="post-list-item">
        <article id="post-Android设计模式" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/11/29/Android设计模式/">Android设计模式</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-11-29T12:44:08.000Z" itemprop="datePublished" class="post-time">
  2016-11-29
</time>

        

 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <h1 id="Android中的设计模式"><a href="#Android中的设计模式" class="headerlink" title="Android中的设计模式"></a>Android中的设计模式</h1><p>Android的代码我接触的并不是特别多，就拿我接触过的代码来说的话有以下几个类：  （不断更新……）</p>
<ul>
<li>组合模式  </li>
<li>策略模式</li>
<li>单例模式</li>
<li>工厂模式</li>
<li>享元模式</li>
<li>适配器模式</li>
<li>原型模式</li>
<li>观察者模式</li>
<li>模版模式  </li>
</ul>
<p>接下来就Android内部的源码来一一解释一下（设计模式的图我就不贴了，网上都可找到）  </p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>首先来说组合模式，这个模式最为熟悉，我们的View（例如：Button，TextView等）和ViewGroup（例如：LinearLayout，Relativelayout等）就是用的这个模式，ViewGroup继承自View但是实现了add，remove等一系列的对View的操作。  </p>
<pre><code> public abstract class ViewGroup extends View implements ViewParent, ViewManager {
 public void addView(View child, int index, LayoutParams params) {
    if (DBG) {
        System.out.println(this + &quot; addView&quot;);
    }
    // addViewInner() will call child.requestLayout() when setting the new LayoutParams
    // therefore, we call requestLayout() on ourselves before, so that the child&apos;s request
    // will be blocked at our level
    requestLayout();
    invalidate(true);
    addViewInner(child, index, params, false);
}     
public void removeView(View view) {
    removeViewInternal(view);
    requestLayout();
    invalidate(true);
}
}
</code></pre><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式就是说我们有一系列的解决方法，我们可以选择其中一种来解决我们实际的问题，我们可以看下面的代码：  </p>
<pre><code>//算法的接口 
public interface PriceStrategy 
{ 
    public int setPrice(int orgPrice); 
} 


//实现一个接口，打7折商品 
public class sevenPercentStrategy implements PriceStrategy 
{ 
public int setPrice(int orgPrice) 
{ 
      System.out.println(&quot;打7折商品&quot;); 
      return orgPrice*0.7; 
} 

} 

//实现一个接口，打5折商品 
public class fivePercentStrategy implements PriceStrategy 
{ 
public int setPrice(int orgPrice) 
{ 
      System.out.println(&quot;打5折商品&quot;); 
      return orgPrice*0.5; 
} 

} 
//实现一个上下文对象 
public class DstPrice 
{   
    private PriceStrategy mPriceStrategy;   

public void setPriceMode(PriceStrategy priceMode) 
{   
    mPriceStrategy = priceMode;   
}   

public int ExeCalPrice(int price) 
{   
    mPriceStrategy.SetPrice(price); 
}   
}   
</code></pre><p>我觉得看到代码基本就都明白了，而在我们的Android的系统当中，我们可以认为我们的Adapter就是用的策略模式，因为我们可以实现不同的Adapter来为ListView等控件来适配，而我们Adapter内部的逻辑又各不相同。 </p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式这个很重要，为什么这么说，在Android操作系统当中，所有的系统服务都是单例模式，例如：  </p>
<ul>
<li>ActivityManagerService</li>
<li>InputMethodManagerService</li>
<li>PackageManagerService</li>
<li>WindowManagerService  </li>
<li>SearchManagerService</li>
<li>……</li>
</ul>
<p>非常多的系统服务，在这里就不一一写出来了，我们如何获取这些服务呢？我们需要查看ContextImp.java这个文件，ContextImp是Context的实现类，我们的Activity也都是继承自这里，我们可以直接调用getSystemService的方法来获取  </p>
<pre><code>class ContextImpl extends Context {
public Object getSystemService(String name) {
    ServiceFetcher fetcher = SYSTEM_SERVICE_MAP.get(name);
    return fetcher == null ? null : fetcher.getService(this);
}    
</code></pre><p>我们以获取输入法服务为例，来继续看，开始的时候我们的所有服务都会被注册到一个hashmap当中，当需要某项服务的时候我们会从这个map当中寻找，例如寻找输入法服务，则会</p>
<pre><code>return InputMethodManager.getInstance();
</code></pre><p>接着再看，  </p>
<pre><code>public final class InputMethodManager {
……
static InputMethodManager sInstance;
……
public static InputMethodManager getInstance() {
    synchronized (InputMethodManager.class) {
        if (sInstance == null) {
            IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);
            IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);
            sInstance = new InputMethodManager(service, Looper.getMainLooper());
        }
        return sInstance;
    }
}
</code></pre><p>这就是单例模式，系统中只会储存一个实例，当我们需要它的时候，只需要调用获取他的方法就可以，不需要new一个出来，我们需要记住的是，Android所有的系统服务全都是单例模式，而且都是在系统初始化的时候生成的。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式这个模式比较有意思，讲这个之前，我们将个例子：<br>第一天，我们进入到饭店（工厂）当中，我们告诉老板，我们需要一份红烧肉（产品），端上来之后，我们就可以开始吃了。<br>第二天，我们又进入到饭店（工厂）当中，然后告诉老板，我们需要一份酸菜鱼（产品），端上来之后，我们就又可以开始吃了。<br>我们每次只需要告诉老板，我们需要什么菜，剩下的你就加工就好了，做好了之后再交给我，这就是工厂模式所做的。我们看一下AsyncTask中的一部分代码：  </p>
<pre><code>private static final ThreadFactory sThreadFactory = new ThreadFactory() {
    private final AtomicInteger mCount = new AtomicInteger(1);

    public Thread newThread(Runnable r) {
        return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement());
    }
};
</code></pre><p>我们可以看到，我们并不关心线程是怎么产生的，我们只是告诉他这个线程的Runnable是什么样的（该怎么运行），你只要负责制作好然后交给我就好了，十分简单。</p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式可能在名称上听的比较少，但实际上就是为了减少系统内存开销，你不必一直new新对象，只是需要的时候从内部抽取，用完之后放回就可以了，可以有效利用资源。<br>前两天我们说的Handler-MessageQueue-Looper当中的Message就是这样的，接下来看一下源码：  </p>
<pre><code>public final class Message implements Parcelable {

……

public static Message obtain() {
    synchronized (sPoolSync) {
        if (sPool != null) {
            Message m = sPool;
            sPool = m.next;
            m.next = null;
            m.flags = 0; // clear in-use flag
            sPoolSize--;
            return m;
        }
    }
    return new Message();
}  
void recycleUnchecked() {
    // Mark the message as in use while it remains in the recycled object pool.
    // Clear out all other details.
    flags = FLAG_IN_USE;
    what = 0;
    arg1 = 0;
    arg2 = 0;
    obj = null;
    replyTo = null;
    sendingUid = -1;
    when = 0;
    target = null;
    callback = null;
    data = null;

    synchronized (sPoolSync) {
        if (sPoolSize &lt; MAX_POOL_SIZE) {
            next = sPool;
            sPool = this;
            sPoolSize++;
        }
    }
}
</code></pre><p>对系统资源充分利用，不需要自己new对象，需要的时候只需要获取就可以了，十分方便！  </p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器对Android的开发者来说肯定不陌生，当我们写个ListView的时候，我们就需要用到Adapter了，为什么要用适配器呢？<br>首先想一个问题，我们的ListView陈列了三个属性，ID，姓名，成绩，而我们有一堆的Student对象存在了一个ArrayList当中，我们怎么能把这些数据编程一列一列的样子存放在ListView当中呢？这就是Adapter的价值，<strong>它的存在就是为了两种类型不同的数据提供借口，将我们已有的数据，通过我们Adapter搭建的bridge转化成我们可用的数据</strong>。在ListView当中，我们的Adapter有getView的方法，返回的是View对象，因此他将我们的Student对象转化为了View对象。我通常将Adapter理解为一个桥，我觉得真很贴切。</p>
<blockquote>
<p>public interface ListAdapter extends Adapter</p>
<p>public abstract class BaseAdapter implements ListAdapter, SpinnerAdapter</p>
</blockquote>
<pre><code>public interface Adapter {

……

View getView(int position, View convertView, ViewGroup parent);

……

}
</code></pre><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式是个什么样子呢？就是说，当我需要一个产品的时候，我们会去询问商店的管理员，问这里有没有这么样的一个产品，如果有的话，他就会直接拿给我，说这就是；如果没有的话，他就会告诉我说我们这里可以订做你需要的类型的。<br>具体的在Android的中的实现在Intent当中，  </p>
<pre><code>public class Intent implements Parcelable, Cloneable {
public Intent() {
}
public Intent(Intent o) {
    this.mAction = o.mAction;
    this.mData = o.mData;
    this.mType = o.mType;
    this.mPackage = o.mPackage;
    this.mComponent = o.mComponent;
    this.mFlags = o.mFlags;
    this.mContentUserHint = o.mContentUserHint;
    if (o.mCategories != null) {
        this.mCategories = new ArraySet&lt;String&gt;(o.mCategories);
    }
    if (o.mExtras != null) {
        this.mExtras = new Bundle(o.mExtras);
    }
    if (o.mSourceBounds != null) {
        this.mSourceBounds = new Rect(o.mSourceBounds);
    }
    if (o.mSelector != null) {
        this.mSelector = new Intent(o.mSelector);
    }
    if (o.mClipData != null) {
        this.mClipData = new ClipData(o.mClipData);
    }
}
@Override
public Object clone() {
    return new Intent(this);
}
</code></pre><p>这个模式有个特点，就是实现了Cloneable的接口，那如果当我们有个比较复杂的类，而我们又不需要外界知道的时候，我们可以考虑使用原型模式，可以隐藏了具体细节。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式的实现还是挺多的，在我们实现的ListView的Adapter当中，我们可以有这样的方法：  </p>
<pre><code>protected void notifyDataSetChange() {  
    mDataSetObservable.notifyChanged();  
} 
</code></pre><p>用来通知我们的ListView我们的数据更新了，你需要重新绘制图层了。<br>另外还有我们的Button上的onClickListener。  </p>
<pre><code>public class View implements Drawable.Callback, KeyEvent.Callback,
    AccessibilityEventSource {

    ……
    public OnClickListener mOnClickListener;
    private PerformClick mPerformClick;
    ……

    private final class PerformClick implements Runnable {
    @Override
    public void run() {
        performClick();
    }
}

    public interface OnClickListener {
    /**
     * Called when a view has been clicked.
     *
     * @param v The view that was clicked.
     */
    void onClick(View v);
}

public void setOnClickListener(OnClickListener l) {
    if (!isClickable()) {
        setClickable(true);
    }
    getListenerInfo().mOnClickListener = l;
}

public boolean performClick() {
    final boolean result;
    final ListenerInfo li = mListenerInfo;
    if (li != null &amp;&amp; li.mOnClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        li.mOnClickListener.onClick(this);
        result = true;
    } else {
        result = false;
    }

    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
    return result;
}

public boolean onTouchEvent(MotionEvent event) {

……

      if (mPerformClick == null) {
           mPerformClick = new PerformClick();
      }
      if (!post(mPerformClick)) {
           performClick();
      }
……
}
</code></pre><p>我们可以清楚的看到，我们只要是设置了监听器，我们每次点击button的时候，我们都会调用onClick方法，那我们要做的就是填写onClick方法，而Listener就是我们所说的Observer（观察者）而我们的View也就是我们说的observable（被观察者）。<br>观察者和被观察者之间是耦合的关系，有利于系统的设计。</p>
<h2 id="模版模式"><a href="#模版模式" class="headerlink" title="模版模式"></a>模版模式</h2><p>模版模式是我最喜欢的模式，也是我认为最简洁，最好用的方法。<br>它的大体思想可以用这么一个故事来说明：<br>父亲对刚出生的儿子说，你现在还小，但是当你慢慢长大的时候，你需要先学会说话，学会走路，然后开始学习，balabala，因为父亲就是这样子过来的，一大堆终于说完了。而孩子也慢慢长大了，也是按照父亲说的这个顺序做的，但是呢，他说话，走路，学习等一系列事情都是他自己设定的。<br>总体来说，就是说父类将逻辑的顺序都给你写好了，子类省去了一系列复杂的逻辑，你只需要将重要的方法Override就可以了，其余的他自己会在必要的时候调用的。<br>我们用View来说明这个问题：  </p>
<pre><code>public class View implements Drawable.Callback, KeyEvent.Callback,
    AccessibilityEventSource {
    public boolean onTouchEvent(MotionEvent event) {
    ……
    }
    protected void dispatchDraw(Canvas canvas) {

    }
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    }
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
    }
    protected void onDraw(Canvas canvas) {
    }
}
</code></pre><p>在Android的内部，绘制UI的流程是onMeasure，onLayout，onDraw，这些顺序进行的，所以我们实现自定义View（View的子类）的时候我们根本不需要考虑很多的内部逻辑，我们只需要告诉这些方法，大小是多少，怎么放置，怎么画这个View，就算是完事儿了。是不是很简洁？</p>

    
    </div>
    
</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-Handler-MessageQueue-Looper" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/11/26/Handler-MessageQueue-Looper/">Handler-MessageQueue-Looper</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-11-26T14:40:08.000Z" itemprop="datePublished" class="post-time">
  2016-11-26
</time>

        

 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <h1 id="Handler-MessageQueue-Looper"><a href="#Handler-MessageQueue-Looper" class="headerlink" title="Handler-MessageQueue-Looper"></a>Handler-MessageQueue-Looper</h1><p>首先呢，标题上的三个兄弟是用来完成异步操作的，虽然AsyncTask也可以完成，但是每次都启用新线程的话有时候会比较复杂，而这三个放在一起却十分好用。<br>那为什么会有异步操作呢？我认为有以下几个原因：  </p>
<ul>
<li>数据库存储数据较慢容易</li>
<li>网络获取数据受网速影响</li>
<li>子线程无法更新UI  </li>
<li>各种在主线程中进行耗时的操作会使程序ANR</li>
<li>…</li>
</ul>
<p>我先说几个关键性的结论，原因放在后面说。  </p>
<ul>
<li>Hander-MessageQueue-Looper之间是一对一对一的关系</li>
<li>MessageQueue中存放的是Message，每个Message都有一个Target为发送这个信息的Handler（如果未指定的话）</li>
<li>使用Looper前请先调用方法prepare() (主线程例外)</li>
<li>Handler与其实例化的线程相绑定   </li>
</ul>
<p>首先开始说这套系统存在的意义，你一定遇到过下面这种情况：  </p>
<blockquote>
<p>android.view.ViewRoot$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.  </p>
</blockquote>
<p>你在子线程中访问了网络，获取到了返回数据，这时候想要填充控件的内容了，然后他告诉你说不能再非UI线程（主线程）修改UI界面，瞬间爆炸。<br>这时候你就需要者三个兄弟了Handler顾名思义，就是用来处理的，MessageQueue这个是用来存放Handler发送的信息的，而Looper则是循环将MessageQueue中取出来Message交付给Handler来处理的  </p>
<p><img src="http://image.lxway.com/upload/1/36/136c06769c6d0a67f1f05d6fc8e504ac_thumb.png" alt="baidu">  </p>
<p>从网上找了个图 大概是这么个意思  </p>
<p>先从简单的看起：<br>首先Message和MessageQueue这两个确实没什么东西，MessageQueue就是一个Message的队列，没有什么值得深究的，比较重要的Message.obtain()方法则是获取信息池中的一个空白的实例，主要是资源的回收利用。另外Message中有个属性一个Runnable  </p>
<p><em>Runnable callback</em>  </p>
<p>还有就是这个方法（用来改变处理这个信息的handler，讲完后面会明白）： </p>
<pre><code>public void setTarget(Handler target) {
    this.target = target;
}
</code></pre><p>接下来看Looper这个类：<br>首先要说明我们在子线程使用Looper的时候，是需要先prepare()一下才可以使用的，而主线程却不需要，为什么？因为主线程在应用程序启动的时候已经做了这个工作了（在ActivityThread类中，这是应用程序启动的开始），具体的方法在ActivityThread类中的main方法中的Looper.prepareMainLooper();所以不用我们操心了。  </p>
<pre><code> public static void prepare() {
    prepare(true);
}

private static void prepare(boolean quitAllowed) {
    if (sThreadLocal.get() != null) {
        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
    }
    sThreadLocal.set(new Looper(quitAllowed));
}        
</code></pre><p>prepare()这个方法具体的含义也就是设置局部线程，你可以简单理解为单纯的让Looper做好准备   </p>
<pre><code>    public static void loop() {
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);
    }
    final MessageQueue queue = me.mQueue;

    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();

    for (;;) {
        Message msg = queue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }

        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +
                    msg.callback + &quot;: &quot; + msg.what);
        }

        msg.target.dispatchMessage(msg);

        if (logging != null) {
            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);
        }

        // Make sure that during the course of dispatching the
        // identity of the thread wasn&apos;t corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;
                    + Long.toHexString(ident) + &quot; to 0x&quot;
                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;
                    + msg.target.getClass().getName() + &quot; &quot;
                    + msg.callback + &quot; what=&quot; + msg.what);
        }

        msg.recycleUnchecked();
    }
}
</code></pre><p>这是Looper的loop方法，不要看他很长，其实就是不断从MessageQueue中取出来Message交给Message的Target去处理（<strong>注意这一句msg.target.dispatchMessage(msg)</strong>）</p>
<p>首先来看Handler的内部： </p>
<pre><code>public class Handler {  
……
final MessageQueue mQueue;
final Looper mLooper;
final Callback mCallback;
final boolean mAsynchronous;
IMessenger mMessenger;  
……  
}
</code></pre><p>这个代码很明显的说明了一点，handler内部有一个looper和一个messagequeue（建议自行看源码），这就是说为什么它们三个是一对一对一的关系。<br>接下来最关键的时刻到了，就是深究Handler的各个方法：<br>首先从开始的sendMessage分析：  </p>
<pre><code>public final boolean sendMessage(Message msg)
{
    return sendMessageDelayed(msg, 0);
}  
</code></pre><p>很简单的一句话- -，还是调用了其他方法，接着看，  </p>
<pre><code>public final boolean sendMessageDelayed(Message msg, long delayMillis)
{
    if (delayMillis &lt; 0) {
        delayMillis = 0;
    }
    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
}     
</code></pre><p>MDZZ又被骗了又是调用的其他方法，接着看，  </p>
<pre><code>public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
                this + &quot; sendMessageAtTime() called with no mQueue&quot;);
        Log.w(&quot;Looper&quot;, e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}
</code></pre><p>好了，终于看到了，  </p>
<pre><code>private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    msg.target = this;
    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
</code></pre><p>有一句挺关键的</p>
<blockquote>
<p>msg.target = this</p>
</blockquote>
<p>他指明了以后要处理这个message的handler，接下来就没handler的事儿了，就会调用MessageQueue的enqueue方法使信息进入队列。<br>有时候你会发送一个Empty的Message：  </p>
<pre><code>public final boolean sendEmptyMessage(int what)
{
    return sendEmptyMessageDelayed(what, 0);
}
</code></pre><p>接着又调用了：  </p>
<pre><code>public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {
    Message msg = Message.obtain();
    msg.what = what;
    return sendMessageDelayed(msg, delayMillis);
}
</code></pre><p>到这一步你就会发现，其实他和普通的Message一样，都是殊途同归的，最后都会调用到</p>
<blockquote>
<p>sendMessageDelayed(msg, delayMillis)<br>sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis)   </p>
</blockquote>
<p>两个方法。  </p>
<p>你会说你记得还可以post一个Runnable对象的呀。没错，确实如此，下边来说另外一种情况当我们使用Post()方法的时候  </p>
<pre><code>public final boolean post(Runnable r)
{
   return  sendMessageDelayed(getPostMessage(r), 0);
}
</code></pre><p>好像和Message的一样，但getPostMessage(r)是什么鬼，查一下  </p>
<pre><code>private static Message getPostMessage(Runnable r) {
    Message m = Message.obtain();
    m.callback = r;
    return m;
}
</code></pre><p>我的天，居然自行给封装了，把一个Runnable给封装成立一个Message，不出所料，  </p>
<blockquote>
<p>public final boolean postAtTime(Runnable r, long uptimeMillis)<br>public final boolean postDelayed(Runnable r, long delayMillis)</p>
</blockquote>
<p>都是将Runnable对象给封装了起来，还当作普通信息发送过去了，发送信息的都说完了，接下来重头戏，要开始说处理信息了！很重要！  </p>
<p>上边说到了<strong>msg.target.dispatchMessage(msg)</strong>这个很重要，因为handler调用了dispatchMessage(msg)方法：  </p>
<pre><code>public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}
</code></pre><ul>
<li>如果Message中有Runnable对象就运行它；  </li>
<li>如果没有Runnable对象，但是实现了CallBack接口的话，就调用接口中的handleMessage方法；</li>
<li>如果都没有的话，就调用自身已经写好的handleMessage方法；</li>
<li>（老Google还是想的挺周到的，接口是为了避免你要重写一个子类，文档中说的）  </li>
</ul>
<p>解释说明代码：  </p>
<pre><code>private static void handleCallback(Message message) 
{
  message.callback.run();
}
</code></pre><p>你可能会说你见过这种代码(PS.handler_post是在主线程实例化的)：  </p>
<pre><code>new Thread(new Runnable() {

       @Override
       public void run() {
           new_str = &quot;更新UI&quot;;
           /*post方法解决UI更新，直接在runnable里面完成更新操作，这个任务会被添加到handler所在线程的消息队列中，即主线程的消息队列中*/
           handler_post.post(new Runnable() {

               @Override
               public void run() {
                   tv_up.setText(new_str);
               }
           });
       }
   }).start();    
</code></pre><p>这个例子很能说明问题，它启动了一个新的线程，这个线程明显是子线程，子线程中用主线程实例化的一个handler来post了一个runnable来修改UI。  </p>
<p>首先虽然启动的是一个子线程，但是handler是在主线程当中实例化的，所以是跟主线程绑定的，那可能又会有疑问，post的那个Runnable不是又会在一个new的线程中运行吗？答案肯定是否定的，因为你最后只是运行了Runnable的run方法并没有生成新的线程。  </p>
<p>所以Handler-MessageQueue-Looper就都说完了。</p>
<p>然后，然后你就可以为所欲为了（当然这种异步只存在于同一个进程当中）！</p>

    
    </div>
    
</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-Activity-生命周期" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/11/24/Activity-生命周期/">Activity 生命周期</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-11-24T15:00:22.000Z" itemprop="datePublished" class="post-time">
  2016-11-24
</time>

        

 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <h1 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a>Activity 生命周期</h1><p>Activity的生命周期按照顺序来讲一共可以分为7个：  </p>
<ul>
<li>onCreate();  </li>
<li>onStart();  </li>
<li>onResume();  </li>
<li>onPause();  </li>
<li>onStop();  </li>
<li>onRestart();  </li>
<li>onDestroy();  </li>
</ul>
<p>具体的顺序可以看下边的图：<br><img src="http://s16.sinaimg.cn/mw690/71e00b88gda37b3c6040f&amp;690" alt="baidu"><br>接下来就开始结合源码中的文档讲解这些状态：  </p>
<h2 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate()"></a>onCreate()</h2><blockquote>
<ul>
<li>Called when the activity is first created. This is where you should do all of your normal static set up: create views, bind data to lists, etc.  This method also provides you with a Bundle containing the activity’s previously frozen state, if there was one.Always followed by onStart()</li>
<li>You can call {@link #finish} from within this function, in which case onDestroy() will be immediately called without any of the rest of the activity lifecycle ({@link #onStart}, {@link #onResume},{@link #onPause}, etc) executing.   </li>
</ul>
</blockquote>
<p>onCreate()方法是当Activity启动后第一个调用的方法，这时候的Activity还是不可见的，这点很重要，根据文档中的内容提示，这个方法就是用来setContentView()，findViewById()，对一些静态数据块的处理还有绑定数据的。 当然你也可以在这个方法当中调用finish()可以不经过其他的生命周期直接onDestroy()。 </p>
<h2 id="onStart"><a href="#onStart" class="headerlink" title="onStart()"></a>onStart()</h2><blockquote>
<ul>
<li>Called when the activity is becoming visible to the user.  </li>
<li>Called after {@link #onCreate} ; or after {@link #onRestart} when the activity had been stopped, but is now again being displayed to the user.  It will be followed by {@link #onResume}.</li>
</ul>
</blockquote>
<p>这个好像没什么好说的了，就是当界面变为可见的时候，就会调用这个方法，进入onStart状态。  </p>
<p><em>PS.可见与可见是不同的。这里说的可见是activity可见，并不是说view都绘制好了，如果你想从这里取走view的宽高，尝试之后你只能呵呵了。<br>如果非要获取的话，你可以从 onWindowFocusChanged()下手试试。</em></p>
<h2 id="onResume"><a href="#onResume" class="headerlink" title="onResume()"></a>onResume()</h2><blockquote>
<ul>
<li>Called when the activity will start interacting with the user.  At this point your activity is at the top of the activity stack, with user input going to it. Always followed by onPause().</li>
<li>Called after {@link #onRestoreInstanceState}, {@link #onRestart}, or {@link #onPause}, for your activity to start interacting with the user. This is a good place to begin animations, open exclusive-access devices (such as the camera), etc.</li>
<li>Keep in mind that onResume is not the best indicator that your activity is visible to the user; a system window such as the keyguard may be in front.  Use {@link #onWindowFocusChanged} to know for certain that your activity is visible to the user (for example, to resume a game).  </li>
</ul>
</blockquote>
<p>这几段话看起来挺长的，但是核心思想特别简单，就是说你当前的这个Activity已经在系统的ActivityManager的栈顶了！你现在可以和他随意的交互了（动画等）。<strong>但是请注意！请注意！请注意！重要的说三遍：虽然在onResume()中可以交互了，但是并不意味只要调用onResume()就变味可以交互了，其实是最终是需要看onWindowFocusChanged的。</strong> </p>
<h2 id="onPause"><a href="#onPause" class="headerlink" title="onPause()"></a>onPause()</h2><blockquote>
<ul>
<li>Called when the system is about to start resuming a previous activity.  This is typically used to commit unsaved changes to persistent data, stop animations and other things that may be consuming CPU, etc.  Implementations of this method must be very quick because the next activity will not be resumed until this method returns.  Followed by either onResume() returns back to the front, or onStop() if it becomes invisible to the user. </li>
<li>it is important to save persistent data in {@link #onPause} instead of {@link #onSaveInstanceState} because the latter is not part of the lifecycle callbacks</li>
<li>When an activity’s onPause() method is called, it should commit to the backing content provider or file any changes the user has made.  This ensures that those changes will be seen by any other activity that is about to run.  You will probably want to commit your data even more aggressively at key times during your activity’s lifecycle: for example before starting a new activity, before finishing your own activity, when the user switches between input fields, etc.</li>
<li>When activity B is launched in front of activity A, this callback will be invoked on A.  B will not be created until A’s {@link #onPause} returns, so be sure to not do anything lengthy here.</li>
<li>Called as part of the activity lifecycle when an activity is going into the background, but has not (yet) been killed. After receiving this call you will usually receive a following call to {@link #onStop} (after the next activity has been resumed and displayed), however in some cases there will be a direct call back to {@link #onResume} without going through the stopped state.  </li>
</ul>
</blockquote>
<p>在我看来啊，我觉得在整个Activity当中，最终要的流程，或者说最关键，要最小心的可能就是这个onPause()了，为什么这么说？仔细阅读上边的说明，你会得到一些信息：这个流程是当当前Activty为其他Activity进入活动状态时让步，所进入的第一个状态，在这个状态中，他需要储存当前Activity的一些关键信息（用文件，provider等），为其他Activity做一些贡献，当然，最关键的一点是这个时间不可以太长，为什么？<strong>因为当ActivityA要启动ActivityB的时候如果A一直在onPause()状态的话，B是无法进入到onCreate()当中的 - -！ </strong>这就是为什么不要进行耗时的操作，越简单越好。</p>
<h2 id="onStop"><a href="#onStop" class="headerlink" title="onStop()"></a>onStop()</h2><blockquote>
<ul>
<li>Called when the activity is no longer visible to the user, because another activity has been resumed and is covering this one.  This may happen either because a new activity is being started, an existing one is being brought in front of this one, or this one is being destroyed. Followed by either onRestart() if this activity is coming back to interact with the user, or onDestroy() if this activity is going away.</li>
<li>Called when you are no longer visible to the user.  You will next receive either {@link #onRestart}, {@link #onDestroy}, or nothing, depending on later user activity. Note that this method may never be called, in low memory situations where the system does not have enough memory to keep your activity’s process running after its {@link #onPause} method is called.  </li>
</ul>
</blockquote>
<p>这个状态仔细看一下，其实也没什么难的，就是说当一个activity不再对用户可见的时候，就会先onPause(),接着运行onStop(),每当有Activity被另一个遮盖的时候就会发生.</p>
<h2 id="onRestart"><a href="#onRestart" class="headerlink" title="onRestart()"></a>onRestart()</h2><blockquote>
<ul>
<li>Called after your activity has been stopped, prior to it being started again. Always followed by onStart().</li>
<li>Called after {@link #onStop} when the current activity is being re-displayed to the user (the user has navigated back to it).  It will be followed by {@link #onStart} and then {@link #onResume}.  </li>
</ul>
</blockquote>
<p>这个状态更简单，就是一个已经onStart()过后的Activity，被onStop()之后，他的信息还存在，从其他Activity回来时，ActivityManager中会退栈（以后会说明）前一个Activity，<strong>就会调用onRestart()接着onStart()(可见)，后onResume()(可交互)。</strong></p>
<h2 id="onDestroy"><a href="#onDestroy" class="headerlink" title="onDestroy()"></a>onDestroy()</h2><blockquote>
<ul>
<li>The final call you receive before your activity is destroyed.  This can happen either because the activity is finishing (someone called {@link Activity#finish} on it, or because the system is temporarily destroying this instance of the activity to save space.  You can distinguish between these two scenarios with the {@link Activity#isFinishing} method.</li>
<li>Perform any final cleanup before an activity is destroyed.  This can happen either because the activity is finishing (someone called {@link #finish} on it, or because the system is temporarily destroying this instance of the activity to save space.  You can distinguish between these two scenarios with the {@link #isFinishing} method.</li>
<li>Note: do not count on this method being called as a place for saving data! </li>
<li>A new instance of the activity will <em>always</em> be immediately created after this one’s {@link #onDestroy()} is called.  In particular, no messages will be dispatched during this time (when the returned object does not have an activity to be associated with).  </li>
</ul>
</blockquote>
<p>写了这么多，终于到了Activity生命周期中最最后一步了！其实她的使命，就是释放掉资源和内存，切记不要将要储存的信息写在这一步，要写在onPause()里面，最后说明一点就是：当一个Activity被destroy之后会有一个新的Activity立马被Create，而在此期间会停止消息的分发。  </p>
<p><strong>生命周期的东西基本就是这些，也就是把该做的工作写在相应的函数当中，完成它们相应的使命，就ok了！</strong></p>

    
    </div>
    
</article>
    </li>
  
    <li class="post-list-item">
        <article id="post-hello-android" 
  class="article article-type-post" itemprop="blogPost">
     


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2016/11/03/hello-android/">Hello Android</a>
    </h3>
  



    <div class="post-meta">
        <time datetime="2016-11-03T11:11:20.000Z" itemprop="datePublished" class="post-time">
  2016-11-03
</time>

        

 
    </div>
    
    <div class="post-content" id="post-content" itemprop="postContent" >
    
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

    
    </div>
    
</article>
    </li>
  
</ul>

    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<script>
var BLOG_SHARE = {
    title: "Chandy 's Home",
    pic: "/img/logo.png",
    summary: document.getElementsByName('summary')[0].content,
    url: "https://chandy1994.github.io/index.html"
};
</script>
<div class="global-share" id="global-share">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>



<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script src="/js/main.js"></script>



<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<script type="text/template" id="search-tpl">
<li class="item">
    <a href="/{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</script>

<script src="/js/search.js"></script>









</body>
</html>
